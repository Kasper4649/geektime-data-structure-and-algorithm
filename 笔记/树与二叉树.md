# 树与二叉树

## 树

![树](../图示/树.jpg)

![树的属性](../图示/树的属性.jpg)

树的性质：

1. 树中的结点数等于所有结点的度数加 1。
2. 度为 m 的树中第 i 层上至多有 m^(i-1) 个结点（i≥1）。
3. 高度为 h 的 m 叉树至多有 (m^h-1)/(m-1) 个结点。
4. 具有 n 个结点的 m 叉树的最小高度为 logm (n (m-1)+1) 向上取整。
5. **树的路径长度是从树根到每一结点的路径长度的总和**。

## 二叉树

每个结点至多只有两棵子树（即二叉树不存在度大于 2 的结点），子树有左右之分，不能任意颠倒次序。

### 满二叉树

一棵高度为 h，并且含有 2^h-1 个结点的二叉树称为满二叉树，即树中的每一层都含有最多的结点，除叶子结点之外的每个结点度数均为 2. 对于编号为 i 的结点， 如果有双亲，其双亲为 i/2（向下取整），如果有左孩子，则左孩子为 2i，如果有右孩子，则右孩子为 2i+1.

### 完全二叉树

设一个高度为 h，有 n 个结点的二叉树，当且仅当其每一个结点都与高度为 h 的满二叉树中编号为 1~n 的结点一一对应时，称为完全二叉树。
1）若 i≤n/2（向下取整），则结点 i 为分支结点，否则为叶子结点。
2）叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都依次排列在该层最左边的位置上。
3）如果有度为 1 的结点，只可能有一个，且该结点只有左孩子而无右孩子。
4）若 n 为奇数，则每个分支结点都有左子女和右子女；若 n 为偶数，则编号最大的分支结点（编号为 n/2）只有左子女，没有右子女，其余分支结点左右子女都有。

---

二叉树的性质：

1. 非空二叉树上叶子结点等于度为 2 的结点数加 1，即 N0=N2+1。
2. 非空二叉树上第 k 层上至多有 2^(k-1) 个结点。
3. 高度为 H 的二叉树至多有 2^H-1 个结点。
4. 对完全二叉树按从上到下、从左到右的顺序依次编号 1~N，则有以下关系：
   - 当 i>1 时，结点 i 的双亲结点编号为 i/2（向下取整）。
   -  当 2i≤N 时，结点 i 的左孩子编号为 2i，否则无左孩子。
   - 当 2i+1 小于等于 N 时，结点 i 的右孩子编号为 2i+1，否则无右孩子。
   -  结点 i 所在层次（深度）为 log2 i（向下取整）+1。
5. 具有 N 个结点的完全二叉树的高度为 log2 (N+1)（向上取整）或 log2 N（向下取整）+1。

---

### 二叉树存储

#### 1. 顺序存储

用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素。

> 完全二叉树和满二叉树采用顺序存储比较合适。

> 二叉树属于树，都可以用树的存储结构来存储，但是树却不都能用二叉树的存储结构来存储。

![二叉树顺序存储](../图示/二叉树顺序存储.jpg)

#### 2. 链式存储

链式结构是指用一个链表来存储一棵二叉树，二叉树中每一个结点用链表的一个链结点来存储。
在含有 n 个结点的二叉链表中含有 n+1 个空链域。
![二叉树链式存储](../图示/二叉树链式存储.jpg)

### 二叉树遍历

![二叉树遍历](../图示/二叉树遍历.jpg)

时间复杂度均为 O (n)，在递归遍历中，递归工作栈的栈深恰好为树的高度。

层次遍历：需要借助一个队列。

### 线索二叉树

**为了加快查找结点前驱和后继的速度。**

ltag=0（lchild 域指示结点的左孩子），ltag=1（lchild 域指示结点的前驱）。
rtag=0（rchild 域指示结点的右孩子），rtag=1（rchild 域指示结点的后继）。

n 个结点的线索二叉树上含有的线索数为（n+1）。

二叉树在线索化后，仍不能有效求解的问题是**后序线索二叉树中求后序后继**和**前序线索二叉树中求前序前驱**。

后序线索树的遍历仍需要栈的支持。

## 树和森林

双亲表示法：采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。
利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快得到每个结点的双亲结点，但是求结点的孩子时需要遍历整个结构。

孩子表示法：将每个结点的孩子结点都用单链表链接起来形成一个线性结构，则 N 个结点就有 N 个孩子链表（叶子结点的孩子链表为空表）。
寻找子女的操作非常直接，而寻找双亲的操作需要遍历 N 个结点中孩子链表指针域所指向的 N 个孩子链表。

孩子兄弟表示法：又称为二叉树表示法，即以二叉树表作为树的存储结构，使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针和指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点）。
可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。

**树转换为二叉树的规则：每个结点左指针指向它的第一个孩子结点，右指针指向它在树中的相邻兄弟结点，可表示为 “左孩子右兄弟”。由于根结点没有兄弟，所以由树转换而得的二叉树没有右子树。**

**二叉树转换为森林的规则：若二叉树非空，则二叉树根及其左子树为第一棵树的二叉树形式，二叉树根的右子树又可以看做是一个由除第一棵树外的森林转换后的二叉树，应用同样的方法，直到最后产生一棵没有右子树的二叉树为止。**

树的遍历：
先根遍历：若树非空，则先访问根结点，再按从左到右的顺序遍历根结点的每一棵子树。**其访问顺序与这棵树相应二叉树的先序遍历顺序相同。**
后根遍历：若树非空，则按从左到右的顺序遍历根结点的每一棵子树，之后再访问根结点。**其访问顺序与这棵树相应二叉树的中序遍历顺序相同。**
层次遍历：与二叉树的层次遍历思想基本相同，即按层序依次访问各结点。

森林的遍历：
先序遍历森林：访问森林中第一棵树的根结点；先序遍历第一棵树中根结点的子树森林；先序遍历除去第一棵树之后剩余的树构成的森林。
中序遍历森林：中序遍历森林中第一棵树的根结点的子树森林；访问第一棵树的根结点；中序遍历除去第一棵树之后剩余的树构成的森林。



## 树与二叉树的应用

### 二叉排序树 BST

又称为二叉查找树。左子树上所有结点关键字值均小于根结点的关键字值；右子树上所有结点关键字值均大于根结点的关键字值；左右子树本身也分别是一棵二叉排序树。
对二叉排序树进行中序遍历，可以得到一个递增的有序序列。

![二叉查找树](../图示/二叉查找树.jpg)

### 平衡二叉树 AVL

左子树和右子树都是平衡二叉树，且任意结点的左右子树高度差的绝对值不超过 1。
平衡因子的值只可能是 - 1,0 或 1（左子树的高度 - 右子树的高度）。

平衡二叉树的插入：LL 平衡旋转（右单旋转）、RR 平衡旋转（左单旋转）、LR 平衡旋转（先左后右双旋转）、RL 平衡旋转（先右后左双旋转）。

平衡二叉树的查找：平均查找长度为 O (log2 n)。

**高度为 n 的平衡二叉树最少含有的节点数**

f(1) = 1, f(2) = 2, f (n) = f (n-1) + f (n-2) +1,(n>=3)。

### 哈夫曼树

从树根结点到任意结点的路径长度（经过的边数）与该结点上权值的乘积称为该结点的带权路径长度。树中所有叶结点的带权路径长度之和称为该树的带权路径长度。

在含有 N 个带权叶子结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称为最优二叉树。

#### 哈夫曼树的构造

给定 N 个权值分别为 w1~wN 的结点。

1. 将这 N 个结点分别作为 N 棵仅含一个结点的二叉树，构成森林 F。
2. 构造一个新结点，并从 F 中选取两棵根结点权值最小的树作为新结点的左右子树，并且将新结点的权值置为左右子树上根结点的权值之和。
3. 从 F 中删除刚才选出的两棵树，同时将新得到的树加入 F 中。
4. 重复 2 和 3，直至 F 中只剩下一棵树为止。

#### 特点

1. 每个初始结点最终都成为叶结点，并且权值越小的结点到根结点的路径长度越大。
2. 构造过程中共新建了 N-1 个结点（双分支结点），因此哈夫曼树的结点总数为 2N-1。
3. 每次构造都选择 2 棵树作为新结点的孩子，因此哈夫曼树中不存在度为 1 的结点。

#### 可变长度编码

对频率高的字符赋以短编码，而对频率较低的字符赋以较长一些的编码，从而使字符平均编码长度减短，起到压缩数据的效果。
如果没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。
由哈夫曼树构造哈弗曼编码：首先将每个出现的字符当做一个独立的结点，其权值为它出现的频度，构造出相应的哈夫曼树。显然，所有字符结点都出现在叶结点中。我们可以将字符的编码解释为从根至该字符的路径上边标记的序列，其中边标记为 0 表示 “转向左孩子”，标记为 1 表示 “转向右孩子”。

