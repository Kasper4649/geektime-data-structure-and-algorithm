# 线性表
线性表是具有**相同数据类型**的 n(n≥0) 个数据元素的**有限序列**。   

除第一个元素外，每个元素**有且仅有一个直接前驱**。     

除最后一个元素外，每个元素**有且仅有一个直接后继**。    

---

## 1. 顺序存储

即顺序表，用一组**地址连续**的存储单元，依次存储线性表中的数据元素。

存储密度大，能实现**随机访问**。根据下标随机访问的时间复杂度为 O (1)。  

用一个长度为 10 的 int 类型的数组 int [] a = new int [10] 来举例。  
计算机给数组 a [10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。 
元素存储的内存地址：

```C++
    a[i]_address = base_address + i * data_type_size
```

  其中 data_type_size 表示数组中每个元素的大小。
    ![数组](../图示/数组.jpg)

缺点：想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作，平均时间复杂度为 O(n)。

- 删除改进：先记录下已经删除的数据，每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。即 **JVM 标记清除垃圾回收算法的核心思想**。

**数组下标都是从 0 开始**：从数组存储的内存模型上来看，“下标” 最确切的定义应该是 “偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a [0] 就是偏移为 0 的位置，也就是首地址，a [k] 就表示偏移 k 个 type_size 的位置，所以计算 a [k] 的内存地址只需要用这个公式

```C++
a[k]_address = base_address + k * type_size
```

但是，如果数组从 1 开始计数，计算数组元素 a [k] 的内存地址就会变为：

```C++
a[k]_address = base_address + (k-1)*type_size
```

对比两个公式，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。 数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了**减少一次减法操作**，数组选择了从 0 开始编号，而不是从 1 开始。

---

## 2. 链式存储

即单链表。通过一组**任意的存储单元**来存储线性表中的数据元素。

通过 “指针” 将一组零散的内存块串联起来使用。

![单链表](../图示/单链表.jpg)

### 循环链表

![循环链表](../图示/循环链表.jpg)
一种特殊的单链表，循环链表的尾结点指针是指向链表的头结点。  
解决著名的[约瑟夫问题](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)。

### 双向链表

![双向链表](../图示/双向链表.jpg)

支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。  如 Java 中 LinkedHashMap 容器。

支持 O (1) 时间复杂度的情况下找到前驱结点。

### 双向循环链表

![双向循环链表](../图示/双向循环链表.jpg)

### 静态链表（不常用）

借助数组来描述线性表的链式存储结构，指针是结点的相对地址（数组下标），即游标。

插入、删除操作与动态链表相同，只需要修改指针，而不需要移动元素。

## 顺序表与链表比较

![数组VS链表](../图示/数组VS链表.jpg)

---

## 补充

#### LRU 缓存淘汰算法

维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2.  如果此数据没有在缓存链表中，分为两种情况：
   - 如果此时缓存未满，则将此结点直插入到链表的头部；
   - 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

优化：基于链表实现，缓存访问的时间复杂度为O(n)。

引入散列表记录每个数据的位置，将缓存访问的时间复杂度降到O(1)。

#### LeetCode

[链表合集](https://leetcode.com/list/x2jhxlm5/)

