# 线性表
线性表是具有**相同数据类型**的 n(n≥0) 个数据元素的**有限序列**。   

除第一个元素外，每个元素**有且仅有一个直接前驱**。     

除最后一个元素外，每个元素**有且仅有一个直接后继**。    

---

## 1. 顺序存储

即顺序表，用一组**地址连续**的存储单元，依次存储线性表中的数据元素。

存储密度大，能实现**随机访问**。根据下标随机访问的时间复杂度为 O (1)。  

用一个长度为 10 的 int 类型的数组 int [] a = new int [10] 来举例。  
计算机给数组 a [10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。 
元素存储的内存地址：

```
    a[i]_address = base_address + i * data_type_size
```

  其中 data_type_size 表示数组中每个元素的大小。
    ![数组](../图示/数组.jpg)

缺点：想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作，平均时间复杂度为 O(n)。

- 删除改进：先记录下已经删除的数据，每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。即 **JVM 标记清除垃圾回收算法的核心思想**。



**数组下标都是从 0 开始**：从数组存储的内存模型上来看，“下标” 最确切的定义应该是 “偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a [0] 就是偏移为 0 的位置，也就是首地址，a [k] 就表示偏移 k 个 type_size 的位置，所以计算 a [k] 的内存地址只需要用这个公式

```
a[k]_address = base_address + k * type_size
```

但是，如果数组从 1 开始计数，那我们计算数组元素 a [k] 的内存地址就会变为：

```
a[k]_address = base_address + (k-1)*type_size
```

对比两个公式，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。 数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了**减少一次减法操作**，数组选择了从 0 开始编号，而不是从 1 开始。

---

## 2. 链式存储






